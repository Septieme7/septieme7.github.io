<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlueDaydream</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-30T23:31:05.986Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Septieme7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从感知机到神经网络</title>
    <link href="http://yoursite.com/2019/08/31/%E4%BB%8E%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%88%B0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/08/31/从感知机到神经网络/</id>
    <published>2019-08-30T23:29:02.000Z</published>
    <updated>2019-08-30T23:31:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从感知机到神经网络"><a href="#从感知机到神经网络" class="headerlink" title="从感知机到神经网络"></a>从感知机到神经网络</h1><h2 id="一、感知机"><a href="#一、感知机" class="headerlink" title="一、感知机"></a>一、感知机</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。</p><p>听起来复杂，但其实很简单，我们先来看一个感知机的例子：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-48d5a387463d1de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>本例中的感知机有三个输入信号：<img src="https://math.jianshu.com/math?formula=x_1%2C%20x_2%2C%20x_3" alt="x_1, x_2, x_3">（当然，它可以有更多或者更少的输入），他们分别有一个权重: <img src="https://math.jianshu.com/math?formula=w_1%2C%20w_2%2C%20w_3%0A" alt="w_1, w_2, w_3"> , 图中的⚪被称为神经元或节点，输入信号被送往神经元时会被分别乘以固定的权重。神经元的输出是0还是1，由加权和  是否小于或者大于某一个阈值（threshold）决定的，这也被称为“神经元被激活”。</p><p>用数学方法表示就是：</p><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Beqnarray%7D%20%5Cmbox%7Boutput%7D%20%26%20%3D%20%26%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%200%20%26%20%5Cmbox%7Bif%20%7D%20%5Csum_j%20w_j*x_j%20%5Cleq%20%5Cmbox%7B%20threshold%7D%20%5C%5C%201%20%26%20%5Cmbox%7Bif%20%7D%20%5Csum_j%20w_j*x_j%20%20%3E%20%20%5Cmbox%7B%20threshold%7D%20%5Cend%7Barray%7D%20%5Cright.%20%5Cend%7Beqnarray%7D" alt="\begin{eqnarray} \mbox{output} &amp; = &amp; \left\{ \begin{array}{ll} 0 &amp; \mbox{if } \sum_j w_j*x_j \leq \mbox{ threshold} \\ 1 &amp; \mbox{if } \sum_j w_j*x_j  &gt;  \mbox{ threshold} \end{array} \right. \end{eqnarray}"></p><p>感知机的各个信号都有其固有的权重，这些权重来表示各个输入对于输出的重要程度，权重越大，对应权重信号的重要性就越高。</p><p>利用单个感知机，我们可以轻松的模拟，与 和 或 两种运算，但对于异或运算，我们似乎束手无策。</p><h3 id="2-单层感知机的局限性"><a href="#2-单层感知机的局限性" class="headerlink" title="2.单层感知机的局限性"></a>2.单层感知机的局限性</h3><p>异或运算：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-c2ca70eb88b90234.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>思考一下，有没有办法使用单个感知机进行异或运算呢？</p><p>好像真的不行….</p><p>但这是为什么呢，我们先来看看或运算的数学图像：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-cd3a46c8cc02b73d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>这是这个或门数学公式的图像化表示，阴影区域代表输出0，非阴影区域代表输出1，三角和圆圈分别代表和。</p><p>但我们要是用数学图像表示异或运算呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-409e1931a60630b1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>通过异或门的图像化表示，我们发现，这些结果并不按套路出牌，它们的位置无法用一条直线分割成两类。</p><p>也可以说：异或运算是非线性的（线性与非线性在机器学习领域很常见）。</p><p>通过观察感知机的数学公式，我们知道上面的感知机只能被画成直线；但要想正确把异或门的结果分开，必须使用曲线。</p><p>上过计组的大家一定都知道，其实仅使用与门和或门是可以实现所有电路的，所以：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-b8a548467dbd168e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>没错，这就是异或门，不信咱们用真值表验证一下：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-4f808b70260ebe95.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>所以，异或对应的多层感知机已经呼之欲出：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-ee13b6c0ef271419.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>图中的感知机总共由3层构成，但是因为拥有权重的层实际上只有2层（第0层和第1层之间，第1层和第2层之间）所以被称为“2层感知机”，不过也有人称其为“3层感知机”。</p><p>通过这样的双层结构，感知机得以实现异或门，这可以解释为“单层感知机无法解决的问题， 可以通过增加一层感知机来解决”。也就是说，通过叠加层（加深层），感知机能进行更加灵活的表示。</p><h3 id="3-多层感知机"><a href="#3-多层感知机" class="headerlink" title="3.多层感知机"></a>3.多层感知机</h3><p>多层感知机可以实现比之前见到的电路更复杂的电路，比如进行加法运算的加法器也可以使用感知机实现（如计组实现过的那样），编码器等也可以通过感知机实现，其实，用感知机甚至可以表现计算机。</p><p>综上，多层感知机可以进行复杂的表示，甚至可以构建计算机。理论上，可以说2层感知机就能构建计算机。这是因为，亦有研究证明，2层感知机（严格地说是激活函数使用了非线性的sigmoid函数的感知机，会在后面提到）可以表示任意函数。但是，使用2层感知机的构造，通过设定合适的权重来制造计算机还是非常复杂，但只要记住，感知机通过叠加层能够进行非线性的表示，理论上还可以表示计算机进行的处理即可。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>可以说，感知机是神经网络的基础，所以，对于感知机的理解十分重要。</p><h2 id="二、神经网络"><a href="#二、神经网络" class="headerlink" title="二、神经网络"></a>二、神经网络</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><p>通过对感知机的学习，我们知道，即便对于复杂的函数，感知机也隐含着能够表示他的可能性，但是，设定权重的工作，即确定合适的、能符合预期的输入与输出的权重，还是由人工进行的。</p><p>神经网络和感知机有很多的共同点，我们先以他们的差异为中心，来介绍神经网络的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-e6691e1d990d5b1d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>图中就是一个简单的神经网络，其中的“中间层”有时也被称为“隐藏层”。我们也可以用第0层代表输入层，第1层代表中间层（隐藏层），第2层代表输出层。</p><p>再进一步深入以前，我们先再简单回顾一下感知机：</p><p>对于一个简单的双输入感知机，存在公式</p><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Beqnarray%7D%20%5Cmbox%7Boutput%7D%20%26%20%3D%20%26%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%200%20%26%20%5Cmbox%7Bif%20%7D%20%5C%20w_1*x_1%20%2B%20w_2*x_2%20%2B%20b%20%20%5Cleq%20%5Cmbox%7B%200%7D%20%5C%5C%201%20%26%20%5Cmbox%7Bif%20%7D%20%5C%20w_1*x_1%20%2B%20w_2*x_2%20%2B%20b%20%3E%20%20%5Cmbox%7B%200%7D%20%5Cend%7Barray%7D%20%5Cright.%20%5Cend%7Beqnarray%7D" alt="\begin{eqnarray} \mbox{output} &amp; = &amp; \left\{ \begin{array}{ll} 0 &amp; \mbox{if } \ w_1*x_1 + w_2*x_2 + b  \leq \mbox{ 0} \\ 1 &amp; \mbox{if } \ w_1*x_1 + w_2*x_2 + b &gt;  \mbox{ 0} \end{array} \right. \end{eqnarray}"></p><p>b就是阈值，也可以称为偏置的参数，用于控制神经元被激活的容易程度；是表示各个信号重要程度的参数，用于控制各个信号的重要性。</p><p>在之前的感知机图像中，我们并没有将b明确的画出来，如果想要表示它，我们可以这样做：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-eeaf3026af622b15.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>对于之前的公式，我们可引入新函数，将其改写为：</p><p><img src="https://math.jianshu.com/math?formula=y%20%3D%20h%20*%20(b%20%2B%20w_1%20*%20x_1%20%2B%20w_2%20*%20x_%202)" alt="y = h * (b + w_1 * x_1 + w_2 * x_ 2)"></p><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Beqnarray%7D%20%5Cmbox%7Bh(x)%7D%20%26%20%3D%20%26%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%200%20%26%20%5Cmbox%7Bif%20%7D%20%5C%20x%20%5Cleq%20%5Cmbox%7B0%7D%20%5C%5C%201%20%26%20%5Cmbox%7Bif%7D%20%5C%20%5C%20x%20%20%3E%20%20%5Cmbox%7B0%7D%20%5Cend%7Barray%7D%20%5Cright.%20%5Cend%7Beqnarray%7D" alt="\begin{eqnarray} \mbox{h(x)} &amp; = &amp; \left\{ \begin{array}{ll} 0 &amp; \mbox{if } \ x \leq \mbox{0} \\ 1 &amp; \mbox{if} \ \ x  &gt;  \mbox{0} \end{array} \right. \end{eqnarray}"></p><h3 id="2-激活函数"><a href="#2-激活函数" class="headerlink" title="2.激活函数"></a>2.激活函数</h3><p>刚刚出现的函数会将输入信号的加权综合转换为输出信号，这种函数一般被称为<strong>激活函数</strong>，激活函数的作用在于决定如何来激活输入信号的总和。</p><p>在之前已经认识了激活函数家族的第一个成员：像实现与门或门的函数这样的，以阈值为界，一旦输入超过阈值，就切换输出的函数被称为“阶跃函数”。</p><p>因此，可以说感知机中使用了阶跃函数作为激活函数，那么，如果感知机使用其他函数作为激活函数的话会怎么样呢？实际上，如果将激活函数从阶跃函数换成其他函数，就可以进入神经网络的世界了。</p><p>就像下面这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-8695044f2fbff61e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>如图2-3所示，表示神经元的⚪中明确显示了激活函数的计算过程，即信号的加权总和为节点a，然后节点a被激活函数 转换成节点y，这里，我们称a和y为“节点”，其实它和之前所说的“神经元”含义相同。</p><h4 id="2-1-sigmoid函数"><a href="#2-1-sigmoid函数" class="headerlink" title="2.1 sigmoid函数"></a>2.1 sigmoid函数</h4><p>神经网络中经常使用的一个激活函数就是sigmoid函数 。</p><p><img src="https://math.jianshu.com/math?formula=h(x)%20%3D%20%5Cfrac%7B1%7D%7B1%20%2B%20e%5E%7B-x%7D%7D" alt="h(x) = \frac{1}{1 + e^{-x}}"></p><p>（e是自然常数2.7182…）</p><p>神经网络中用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送给下一个神经元。感知机和接下来要介绍的神经网络的主要区别就在于这个激活函数。其他方面，比如神经元的多层连接的构造、信号的传递方法等，基本上和感知机是一样的。</p><p>我们先看看阶跃函数的图像：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-273e3c37938161bf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>如图所示，阶跃函数以0为界，输出从0切换为1（或者从1切换为0）。 它的值呈阶梯式变化，所以称为阶跃函数。</p><h4 id="2-2-sigmoid函数和阶跃函数的比较"><a href="#2-2-sigmoid函数和阶跃函数的比较" class="headerlink" title="2.2 sigmoid函数和阶跃函数的比较"></a>2.2 sigmoid函数和阶跃函数的比较</h4><p>现在我们来比较一下sigmoid 函数和阶跃函数，把他们重合在一起：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-67900ed126a9fe09.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>可以明显观察到，他们的平滑性不同，sigmoid函数是一条平滑的曲线，输出随着输入发生连续性的变化。而阶跃函数以0为界，输出发生急剧性的变化，sigmoid函数的平滑性对神经网络的学习具有重要意义。</p><p>另一个不同点是，相对于阶跃函数只能返回0或1，而sigmoid函数可以返回0到1之间的任意实数，也就是说，感 知机中神经元之间流动的是0或1的二元信号，而神经网络中流动的是连续 的实数值信号。</p><p>而他们的共同性质是：如果从宏观视角看图2-5，可以发现它们 具有相似的形状。实际上，两者的结构均是“输入小时，输出接近0（为 0）； 随着输入增大，输出向1靠近（变成1）”。也就是说，当输入信号为重要信息时， 阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时， 两者都输出较小的值。还有一个共同点是，不管输入信号有多小，或者有多大，输出信号的值都在0到1之间。</p><p>还有一点就是：两者均为非线性函数。 sigmoid函数是一条曲线，阶跃函数是一条像阶梯一样的折线，两者都属于<strong>非线性</strong>的函数。</p><h4 id="2-3-非线性函数"><a href="#2-3-非线性函数" class="headerlink" title="2.3 非线性函数"></a>2.3 非线性函数</h4><p>神经网络的激活函数必须使用非线性函数，如果使用线性函数的话，加深神 经网络的层数就没有意义了。</p><p>这是为什么呢？</p><p>线性函数的问题在于，不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</p><p>为了具体地理解这一点，我们来思考下面这个简单的例子。</p><p>假如把线性函数  作为激活函数，把    的运算对应3层神经网络A。这个运算会进行  的乘法运算，但是同样的处理可以由 这一次乘法运算（即没有隐藏层的神经网络）来表示。</p><p>如本例所示， 使用线性函数时，无法发挥多层网络带来的优势，是一种“浪费”。因此，为了发挥叠加层所带来的优势，激活函数必须使用非线性函数。</p><h4 id="2-4-ReLu函数"><a href="#2-4-ReLu函数" class="headerlink" title="2.4 ReLu函数"></a>2.4 ReLu函数</h4><p>可以说，到目前为止，sigmoid函数和ReLu函数是最常用的两种激活函数。</p><p>ReLU函数在输入大于0时，直接输出该值；在输入小于等于0时，输出0：</p><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Beqnarray%7D%20%5Cmbox%7Bh(x)%7D%20%26%20%3D%20%26%20%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bll%7D%200%20%26%20%5Cmbox%7Bif%20%7D%20%5C%20x%20%20%5Cleq%20%5Cmbox%7B%200%7D%20%5C%5C%20x%20%26%20%5Cmbox%7Bif%20%7D%20%5C%20x%20%3E%20%20%5Cmbox%7B%200%7D%20%5Cend%7Barray%7D%20%5Cright.%20%5Cend%7Beqnarray%7D" alt="\begin{eqnarray} \mbox{h(x)} &amp; = &amp; \left\{ \begin{array}{ll} 0 &amp; \mbox{if } \ x  \leq \mbox{ 0} \\ x &amp; \mbox{if } \ x &gt;  \mbox{ 0} \end{array} \right. \end{eqnarray}"></p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-8d4884a0ce9c5262.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="3-多维数组的运算"><a href="#3-多维数组的运算" class="headerlink" title="3.多维数组的运算"></a>3.多维数组的运算</h4><p>这里一些十分基础的矩阵运算就不再提及了， 毕竟大家都已经学过线性代数了。</p><p>所以我们来直接看一看他在神经网络中是如何进行的：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-df3bf47ff346a29e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>信号在各层之间的传递：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-a7ef51846e23bf99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>图2-8中增加了表示偏置的神经元“1”。请注意，偏置的右下角的索引号只有一个。这是因为前一层的偏置神经元（神经元“1”）只有一个。</p><p>为了确认前面的内容，现在用数学式表示，通过加权信号和偏置的和按如下方式进行计算：</p><p><img src="https://math.jianshu.com/math?formula=a_1%5E%7B(1)%7D%20%20%3D%20%20w_%7B11%7D%5E%7B(1)%7D%20*%20x_1%2B%20w_%7B12%7D%5E%7B(1)%7D%20*%20x_2%20%2B%20b_1%5E%7B(1)%7D" alt="a_1^{(1)}  =  w_{11}^{(1)} * x_1+ w_{12}^{(1)} * x_2 + b_1^{(1)}"></p><p>如果使用矩阵的乘法运算，则可以将第1层的加权和表示成下面的式子：</p><p><img src="https://math.jianshu.com/math?formula=A%5E%7B(1)%7D%20%3D%20XW%5E%7B(1)%7D%20%2B%20B%5E%7B(1)%7D" alt="A^{(1)} = XW^{(1)} + B^{(1)}"> </p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-e0a14940f94b6296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在我们加入激活函数后向后传递：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-0fa9b77b73adb81a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>当神经网络进行到最后一层（输出层）时，为了和之前的流程保持一致，我们对输出层也增加一个激活函数，即恒等函数。恒等函数会将输入按原样输出，输出层的激活函数用σ()表示，不同于隐 藏层的激活函数h()。</p><blockquote><p>Tip ：输出层所用的激活函数，要根据求解问题的性质决定。一般地，回 归问题可以使用恒等函数，二元分类问题可以使用sigmoid函数， 多元分类问题可以使用softmax函数（会在后面介绍）。</p></blockquote><h4 id="4-恒等函数和softmax函数"><a href="#4-恒等函数和softmax函数" class="headerlink" title="4.恒等函数和softmax函数"></a>4.恒等函数和softmax函数</h4><p>恒等函数会将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。</p><p>而在分类问题中使用的softmax函数可以如下表示：</p><p><img src="https://math.jianshu.com/math?formula=y_k%20%3D%20%5Cfrac%7Be%5E%7Ba_k%7D%7D%7B%20%20%5Csum_%7Bi%20%3D%201%7D%5En%20%20%7Be%5E%7Ba_i%7D%7D%7D%20" alt="y_k = \frac{e^{a_k}}{  \sum_{i = 1}^n  {e^{a_i}}} "></p><p>如图所示， softmax函数的输出通过箭头与所有的输入信号相连，输出层的各个神经元都受到所有输入信号的影响。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-c36d66ba147aaf53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="4-1-softmax函数的特征"><a href="#4-1-softmax函数的特征" class="headerlink" title="4.1 softmax函数的特征"></a>4.1 softmax函数的特征</h4><p>softmax函数的输出是0.0到1.0之间的实数。并且，softmax 函数的输出值的总和是1。输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。</p><p>假设上图的结果， <img src="https://math.jianshu.com/math?formula=y_1" alt="y_1">是0.245（24.5 %）， <img src="https://math.jianshu.com/math?formula=y_2" alt="y_2">是0.737（73.7%）。从概率的结果来看，我们可以说“因为第2个元素的概率最高，所以答案是第2个类别”，通过使用softmax函数，我们可以用概率的（统 计的）方法处理问题。</p><p>显然，各输出之间的大小关系也不会发生改变，一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。</p><h4 id="4-2-输出层神经元的数量"><a href="#4-2-输出层神经元的数量" class="headerlink" title="4.2 输出层神经元的数量"></a>4.2 输出层神经元的数量</h4><p>输出层的神经元数量需要根据待解决的问题来决定。对于分类问题，输出层的神经元数量一般设定为类别的数量。</p><blockquote><p>求解机器学习问题的步骤可以分为“学习” 和“推理”两个阶段。首先，在学习阶段进行模型的学习B，然后，在推理阶段，用学到的 模型对未知的数据进行推理（分类）。如前所述，推理阶段一般会省 略输出层的softmax函数。在输出层使用softmax函数是因为它和神经网络的学习有关（后面会提到）。</p></blockquote><h4 id="4-3-批处理"><a href="#4-3-批处理" class="headerlink" title="4.3 批处理"></a>4.3 批处理</h4><p>批处理对计算机的运算大有利处，可以大幅缩短每张图像的处理时间。这是因为大多数处理 数值计算的库都进行了能够高效处理大型数组运算的最优化。</p><p>并且，在神经网络的运算中，当数据传送成为瓶颈时，批处理可以减轻数 据总线的负荷（严格地讲，相对于数据读入，可以将更多的时间用在计算上）。也就是说，批处理一次性计算大型数组要比分开逐步计算各个小型数组速度更快。</p><p>一般通过设置batch_size来设置批数量。</p><h2 id="三、神经网络的学习"><a href="#三、神经网络的学习" class="headerlink" title="三、神经网络的学习"></a>三、神经网络的学习</h2><p>神经网络的特征就是可以从数据中学习。所谓“从数据中学习”，是指 可以由数据自动决定权重参数的值。</p><p>在感知机的例子中，我们对照着真值表，人工设定了参数的值，但是那时的参数只有3个。 而在实际的神经网络中，参数的数量成千上万，在层数更深的深度学习中， 参数的数量甚至可以上亿，想要人工决定这些参数的值是不可能的</p><p>机器学习的方法中，由机器从收集到的数据中找出规律性。与从零开始 想出算法相比，这种方法可以更高效地解决问题，也能减轻人的负担。但是 需要注意的是，将图像转换为向量时使用的特征量仍是由人设计的。对于不同的问题，必须使用合适的特征量（必须设计专门的特征量），才能得到好的结果。</p><p>比如，识别动物和识别数字，显然需要使用不同的特征量。</p><p>到这里，我们介绍了两种针对机器学习任务的方法。将这两种方法用图来表示，。图中还展示了神经网络（深度学习）的方法，可以看出该方法不存在人为介入，神经网络直接学习图像本身。而在第2个方法，即利用特征量和机器学习的方法中，特征量仍是由人工设计的，但在神经网络中，连图像中包含的重要特征量也都是由机器来学习的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-9a4fcd3ad49ca24e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>神经网络的优点是对所有的问题都可以用同样的流程来解决。比如，不管要求解的问题是识别数字，还是识别动物或是识别人脸，神经网络都是通过不断地学习所提供的数据，尝试发现待求解的问题的模式。也就是说，与待处理的问题无关，神经网络可以将数据直接作为原始数据，进行“端对端”的学习，这也正是神经网络强大的地方。</p><h3 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h3><p>机器学习中，一般将数据分为<strong>训练数据</strong>和<strong>测试数据</strong>两部分来进行学习和 实验等。首先，使用训练数据进行学习，寻找最优的参数；然后，使用测试 数据评价训练得到的模型的实际能力。</p><p>为什么需要将数据分为训练数据和测试数据呢？因为我们追求的是模型的泛化能力。为了正确评价模型的<strong>泛化能力</strong>，就必须划分训练数据和测试数据。另外，训练数据也可以称为<strong>监督数据</strong>。</p><p>泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的 能力。获得泛化能力是机器学习的最终目标，如果系统 只能正确识别已有的训练数据，那有可能是只学习到了训练数据中的个人的习惯写法。</p><p>因此，仅仅用一个数据集去学习和评价参数，是无法进行正确评价的。 这样会导致可以顺利地处理某个数据集，但无法处理其他数据集的情况。只对某个数据集过度拟合的状态称为<strong>过拟合</strong>避免过拟合也是机器学习的一个重要课题。</p><h3 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h3><p>损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致。</p><h4 id="2-1-均方误差"><a href="#2-1-均方误差" class="headerlink" title="2.1 均方误差"></a>2.1 均方误差</h4><p>可以用作损失函数的函数有很多，其中最有名的是均方误差（mean squared error）。均方误差如下式所示：</p><p><img src="https://math.jianshu.com/math?formula=E%20%3D%20%5Cfrac%7B1%7D%7B2%7D%5Csum%5Cnolimits_%7Bk%7D%20%7B(y_k%20-%20t_k)%7D%20%5E%202%20" alt="E = \frac{1}{2}\sum\nolimits_{k} {(y_k - t_k)} ^ 2 "></p><p>这里，<img src="https://math.jianshu.com/math?formula=y_k" alt="y_k">是表示神经网络的输出，<img src="https://math.jianshu.com/math?formula=t_k" alt="t_k">表示监督数据，k表示数据的维数。</p><h4 id="2-2-交叉熵误差"><a href="#2-2-交叉熵误差" class="headerlink" title="2.2 交叉熵误差"></a>2.2 交叉熵误差</h4><p>除了均方误差之外，交叉熵误差（cross entropy error）也经常被用作损 失函数。交叉熵误差如下式所示：</p><p><img src="https://math.jianshu.com/math?formula=E%20%3D%20-%5Csum_%7Bk%7D%20t_k%20%5Cln%20y_k" alt="E = -\sum_{k} t_k \ln y_k"></p><p>实际上只计算对应正确解标签的输出的自然对数。比如，假设正确解标签的索引是“2”，与之对应的神经网络的输出是0.6，则交叉熵误差是−log 0.6 = 0.51；若“ 2”对应的输出是0.1，则交叉熵误差为−log0.1 = 2.30。 也就是说，交叉熵误差的值是由正确解标签所对应的输出结果决定的。</p><h4 id="2-3-mini-batch学习"><a href="#2-3-mini-batch学习" class="headerlink" title="2.3 mini-batch学习"></a>2.3 mini-batch学习</h4><p>机器学习使用训练数据进行学习。使用训练数据进行学习，严格来说， 就是针对训练数据计算损失函数的值，找出使该值尽可能小的参数。因此，计算损失函数时必须将所有的训练数据作为对象。也就是说，如果训练数据有100个的话，我们就要把这100个损失函数的总和作为学习的指标，以交叉熵误差为例，可以写成下面的式子：</p><p><img src="https://math.jianshu.com/math?formula=E%20%3D%20-%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bn%7D%20%5Csum_%7Bk%7D%20t_%7Bnk%7D%20%5Cln%20y_%7Bnk%7D" alt="E = -\frac{1}{N} \sum_{n} \sum_{k} t_{nk} \ln y_{nk}"></p><p>这里,假设数据有N个，<img src="https://math.jianshu.com/math?formula=t_%7Bnk%7D%0A" alt="t_{nk}">表示第n个数据的第k个元素的值。</p><p>如果遇到大数据， 数据量会有几百万、几千万之多，这种情况下以全部数据为对象计算损失函 数是不现实的。因此，我们从全部数据中选出一部分，作为全部数据的“近 似”。神经网络的学习也是从训练数据中选出一批数据（称为mini-batch,小 批量），然后对每个mini-batch进行学习。比如，从60000个训练数据中随机 选择100笔，再用这100笔数据进行学习。这种学习方式称为<strong>mini-batch学习</strong>。</p><h3 id="3-数值微分"><a href="#3-数值微分" class="headerlink" title="3.数值微分"></a>3.数值微分</h3><h4 id="3-1-导数"><a href="#3-1-导数" class="headerlink" title="3.1 导数"></a>3.1 导数</h4><p>这个大家显然都学过，物理意义和数学意义就不在这里多讲了</p><h4 id="3-2-数值微分的实现"><a href="#3-2-数值微分的实现" class="headerlink" title="3.2 数值微分的实现"></a>3.2 数值微分的实现</h4><p>利用微小的差分求导数的过程称为数值微分（numerical  differentiation）。而基于数学式的推导求导数的过程，则用“解析性”（analytic）一词，称为“解析性求解”或者“解析性求导”。比如， y = x2的导数，可以通过解析性地求解出来。因此，当x = 2时， y的导数为4。解析性求导得到的导数是不含误差的“真的导数”。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-8bac39373c36dd2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="3-3-偏导数"><a href="#3-3-偏导数" class="headerlink" title="3.3 偏导数"></a>3.3 偏导数</h4><p>偏导数和单变量的导数一样，都是求某个地方的斜率。不过， 偏导数需要将多个变量中的某一个变量定为目标变量，并将其他变量固定为某个值。在上例的代码中，为了将目标变量以外的变量固定到某些特定的值 上，我们定义了新函数。然后，对新定义的函数应用了之前的求数值微分的 函数，得到偏导数。</p><h3 id="4-梯度"><a href="#4-梯度" class="headerlink" title="4.梯度"></a>4.梯度</h3><p>在刚才的例子中，我们按变量分别计算了<img src="https://math.jianshu.com/math?formula=x_0%0A" alt="x_0">和<img src="https://math.jianshu.com/math?formula=x_1%0A" alt="x_1">的偏导数。现在，我们希望一起计算<img src="https://math.jianshu.com/math?formula=x_0%0A" alt="x_0">和<img src="https://math.jianshu.com/math?formula=x_1%0A" alt="x_1">的偏导数。比如，我们来考虑求<img src="https://math.jianshu.com/math?formula=x_0%0A" alt="x_0"> = 3,<img src="https://math.jianshu.com/math?formula=x_1" alt="x_1"> = 4时(x0,x 1) 的偏导数 ，由全部变量的偏导数汇总而成的向量称为梯度（gradient）。</p><p>如图所示<img src="https://math.jianshu.com/math?formula=f(x_0%20%2B%20x_1)%20%3D%20x_0%5E2%20%2B%20x_1%5E2%0A" alt="f(x_0 + x_1) = x_0^2 + x_1^2">的梯度呈现为有向向量（箭头），我们发现梯度指向函数的“最低处”（最小值），就像指南针 一样，所有的箭头都指向同一点。其次，我们发现离“最低处”越远，箭头越大。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-c9ac0b14dd02bb16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>虽然图4-9中的梯度指向了最低处，但并非任何时候都这样。实际上， 梯度会指向各点处的函数值降低的方向。更严格地讲，梯度指示的方向 是各点处的函数值减小最多的方向。</p><h4 id="4-1-梯度法"><a href="#4-1-梯度法" class="headerlink" title="4.1 梯度法"></a>4.1 梯度法</h4><p>机器学习的主要任务是在学习时寻找最优参数。同样地，神经网络也必须在学习时找到最优参数（权重和偏置）。这里所说的最优参数是指损失函数取最小值时的参数。但是，一般而言，损失函数很复杂，参数空间庞大，我们不知道它在何处能取得最小值。而通过巧妙地使用梯度来寻找函数最小值 （或者尽可能小的值）的方法就是梯度法。</p><p>梯度表示的是各点处的函数值减小最多的方向。因此，无法保证梯度所指的方向就是函数的最小值或者真正应该前进的方向。实际上，在复杂的函数中，梯度指示的方向基本上都不是函数值最小处。</p><blockquote><p>函数的极小值、最小值以及被称为鞍点的地方， 梯度为0。极小值是局部最小值，也就是限定在某个范围内的最 小值。鞍点是从某个方向上看是极大值，从另一个方向上看则是极小值的点。</p><p>虽然梯度法是要寻找梯度为0的地方，但是那个地方不一定就是最小值（也有可能是极小值或者鞍点）。此外，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区， 陷入被称为“学习高原”的无法前进的停滞期。 </p></blockquote><p>虽然梯度的方向并不一定指向最小值，但沿着它的方向能够最大限度地 减小函数的值，在梯度法中，函数的取值从当前位置沿着梯 度方向前进一定距离，然后在新的地方重新求梯度，再沿着新梯度方向前进， 如此反复，不断地沿梯度方向前进。</p><p>严格地讲， 寻找最小值的梯度法称为<strong>梯度下降法</strong> ， 寻找最大值的梯度法称为<strong>梯度上升法，</strong>但是通过反转损失函数的符号，求最小值的问题和求最大值的问题会变成相同的问题。</p><p><img src="https://math.jianshu.com/math?formula=x_0%20%3D%20x_0%20-%20%5Ceta%20%5Cfrac%7B%5Cvartheta%20f%7D%7B%5Cvartheta%20x_0%7D%20" alt="x_0 = x_0 - \eta \frac{\vartheta f}{\vartheta x_0} ">         <img src="https://math.jianshu.com/math?formula=x_1%20%3D%20x_1%20-%20%5Ceta%20%5Cfrac%7B%5Cvartheta%20f%7D%7B%5Cvartheta%20x_1%7D" alt="x_1 = x_1 - \eta \frac{\vartheta f}{\vartheta x_1}"></p><p>η表示更新量，在神经网络的学习中，称为学习率。学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数。这个步骤会反复执行，也就是说，每 一步都按式（4.7）更新变量的值，通过反复执行此步骤，逐渐减小函数值。 </p><p>学习率需要事先确定为某个值，比如0.01或0.001。一般而言，这个值过大或过小，都无法抵达一个“好的位置”。在神经网络的学习中，一般会 一边改变学习率的值，一边确认学习是否正确进行了。</p><h4 id="4-2-神经网络的梯度"><a href="#4-2-神经网络的梯度" class="headerlink" title="4.2 神经网络的梯度"></a>4.2 神经网络的梯度</h4><p>神经网络的学习也要求梯度，这里所说的梯度是指损失函数关于权重参数的梯度。比如，有一个只有一个形状为2×3的权重W的神经网络，损失函数用L表示。此时，梯度可以用<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20w%7D%20" alt="\frac{\vartheta L}{\vartheta w} ">表示。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-af612f364c6db471.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>然后我们用学习率乘以在相应位置上的梯度，更新权重。</p><p>相比数值微分法求梯度， 使用误差反向传播法精度更高，和解析法是一致的。误差反向传播法是通过计算图实现的，假如有时间可以另行介绍。</p><h3 id="5-深度学习算法的实现"><a href="#5-深度学习算法的实现" class="headerlink" title="5.深度学习算法的实现"></a>5.深度学习算法的实现</h3><p>关于神经网络学习的基础知识，到这里就全部介绍完了。“损失函数”，“ mini-batch”，“梯度”，“梯度下降法”等关键词已经悉数登场，接下来我们来确认一下神经网络的学习步骤：</p><p><strong>前提</strong>         <strong>神经网络存在合适的权重和偏置，调整权重和偏置以便拟合训练数据的 过程称为“学习”。神经网络的学习分成下面4个步骤。</strong></p><p><strong>步骤1</strong>    <strong>（mini-batch） 从训练数据中随机选出一部分数据，这部分数据称为mini-batch。我们 的目标是减小mini-batch的损失函数的值。</strong></p><p><strong>步骤2</strong>    <strong>（计算梯度） 为了减小mini-batch的损失函数的值，需要求出各个权重参数的梯度。 梯度表示损失函数的值减小最多的方向。</strong></p><p><strong>步骤3</strong>    <strong>（更新参数） 将权重参数沿梯度方向进行微小更新。</strong></p><p><strong>步骤4</strong>    <strong>（重复） 重复步骤1、步骤2、步骤3。</strong></p><p>神经网络的学习按照上面4个步骤进行。这个方法通过梯度下降法更新参数，不过因为这里使用的数据是随机选择的mini batch数据，所以又称为<strong>随机梯度下降法（SGD）</strong>。“随机”指的是“随机选择的” 的意思，因此，随机梯度下降法是“对随机选择的数据进行的梯度下降法”。 深度学习的很多框架中，随机梯度下降法一般由一个名为SGD的函数来实现。 SGD来源于随机梯度下降法的英文名称的首字母。 </p><h2 id="三、学习的技巧"><a href="#三、学习的技巧" class="headerlink" title="三、学习的技巧"></a>三、学习的技巧</h2><p>将会介绍神经网络的学习中的一些重要观点，主题涉及寻找最优权重参数的最优化方法、权重参数的初始值、超参数的设定方法等。此外，为了应对过拟合，还将介绍权值衰减、Dropout等正则化方法， 最后将对近年来众多研究中使用的Batch Normalization方法进行简单的介绍。</p><h3 id="1-参数的更新"><a href="#1-参数的更新" class="headerlink" title="1.参数的更新"></a>1.参数的更新</h3><p>神经网络的学习的目的是找到使损失函数的值尽可能小的参数。这是寻 找最优参数的问题，解决这个问题的过程称为最优化（optimization）。</p><p>在之前，为了找到最优参数，我们将参数的梯度（导数）作为了线索。 使用参数的梯度，沿梯度方向更新参数，并重复这个步骤多次，从而逐渐靠 近最优参数，这个过程称为随机梯度下降法<strong>（SGD）。</strong>SGD是一个简单的方法，不过比起胡乱地搜索参数空间，也算是“聪 明”的方法。但是，根据不同的问题，也存在比SGD更加聪明的方法。</p><h4 id="1-1-SGD"><a href="#1-1-SGD" class="headerlink" title="1.1 SGD"></a>1.1 SGD</h4><p><img src="https://math.jianshu.com/math?formula=W%20%5Cleftarrow%20%20W%20-%20%5Ceta%20%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20" alt="W \leftarrow  W - \eta \frac{\vartheta L}{\vartheta W} "></p><p>这里把需要更新的权重参数记为W，把损失函数关于W的梯度记为<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20" alt="\frac{\vartheta L}{\vartheta W} "> 。 η表示学习率，实际上会取0.01或0.001这些事先决定好的值。</p><p>虽然SGD简单，并且容易实现，但是在解决某些问题时可能没有效率。 这里，在指出SGD的缺点之际，我们来思考一下求下面这个函数的最小值的问题:</p><p><img src="https://math.jianshu.com/math?formula=f(x%2C%20y)%20%3D%20%5Cfrac%7B1%7D%7B20%7Dx%5E2%20%2B%20y%5E2" alt="f(x, y) = \frac{1}{20}x^2 + y^2"></p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-1dd77074e3014d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>现在看一下这个函数的梯度。如果用图表示梯度的话，则如图所示，这个梯度的特征是，y轴方向上大，x轴方向上小。换句话说， 就是y轴方向的坡度大，而x轴方向的坡度小。这里需要注意的是，虽然式 （6.2）的最小值在(x,y) = (0, 0)处，但是图中的梯度在很多地方并没有指 向(0, 0)。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-3b2a5959c0c7e81c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>如果我们对这种形状的函数应用SGD，明显会呈现“之”字形移动这种非常低效的路径，所以，SGD的缺点是，如果函数的形状非均向（anisotropic），比如呈延伸状，搜索 的路径就会非常低效。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-578483b2710415d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>所以接下来我们介绍几种优化后的方法，很多原理都比较复杂，大家可以自行查阅论文，这里主要是介绍。</p><h4 id="1-2-Momentum"><a href="#1-2-Momentum" class="headerlink" title="1.2 Momentum"></a>1.2 Momentum</h4><p>Momentum是“动量”的意思，和物理有关。用数学式表示Momentum方 法，如下所示：</p><p><img src="https://math.jianshu.com/math?formula=W%20%5Cleftarrow%20%20%5Calpha%20%5Cnu%20%20-%20%5Ceta%20%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20" alt="W \leftarrow  \alpha \nu  - \eta \frac{\vartheta L}{\vartheta W} "></p><p>和前面的SGD一样，W表示要更新的权重参数， <img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20" alt="\frac{\vartheta L}{\vartheta W} ">表示损失函数关 于W的梯度，η表示学习率。这里新出现了一个变量v，对应物理上的速度。这个公式表示了物体在梯度方向上的受力，在这个力的作用下，物体的速度增加这一物理法则。其中中有 αv这一项。在物体不受任何力时，该项承担使物体逐渐减速的任务（α设定为0.9之类的值），对应物理上的地面摩擦或空气阻力。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-685deb31c8bf1bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>可以看到，当我们使用momentum优化时，更新路径就像小球在碗中滚动一样。和SGD相比，我们发现 “之”字形的“程度”减轻了。这是因为虽然x轴方向上受到的力非常小，但是因为一直在同一方向上受力，所以朝同一个方向会有一定的加速。反过来，虽然y轴方向上受到的力很大，但是因为交互地受到正方向和反方向的力，它们会互相抵消，所以y轴方向上的速度不稳定。</p><h4 id="1-3-AdaGrad"><a href="#1-3-AdaGrad" class="headerlink" title="1.3 AdaGrad"></a>1.3 AdaGrad</h4><p>在神经网络的学习中，学习率（数学式中记为η）的值很重要。学习率过小， 会导致学习花费过多时间；反过来，学习率过大，则会导致学习发散而不能 正确进行。 </p><p>在关于学习率的有效技巧中，有一种被称为学习率衰减（learning rate decay）的方法，即随着学习的进行，使学习率逐渐减小。实际上，一开始“多” 学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。 逐渐减小学习率的想法，相当于将“全体”参数的学习率值一起降低。 </p><p>而AdaGrad 进一步发展了这个想法，针对“一个一个”的参数，赋予其“定制”的值。 AdaGrad会为参数的每个元素适当地调整学习率，与此同时进行学习 。下面，让我们用数学式表示AdaGrad的更新方法。</p><p><img src="https://math.jianshu.com/math?formula=h%20%5Cleftarrow%20%20h%20-%20%5Ceta%20%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20%20%5Codot%20%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20%20" alt="h \leftarrow  h - \eta \frac{\vartheta L}{\vartheta W}  \odot \frac{\vartheta L}{\vartheta W}  ">        <img src="https://math.jianshu.com/math?formula=W%20%5Cleftarrow%20%20W%20-%20%5Ceta%20%5Cfrac%7B1%7D%7B%5Csqrt%7Bh%7D%20%7D%20%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20" alt="W \leftarrow  W - \eta \frac{1}{\sqrt{h} } \frac{\vartheta L}{\vartheta W} "></p><p>和前面的SGD一样，W表示要更新的权重参数， <img src="https://math.jianshu.com/math?formula=%20%5Cfrac%7B%5Cvartheta%20L%7D%7B%5Cvartheta%20W%7D%20" alt=" \frac{\vartheta L}{\vartheta W} ">表示损失函数关 于W的梯度，η表示学习率。这里新出现了变量h，它保存了以前的所有梯度值的平方和, <img src="https://math.jianshu.com/math?formula=%5Codot%20" alt="\odot ">表示对应矩阵元素的乘法。 然后，在更新参数时，通过乘以<img src="https://math.jianshu.com/math?formula=%20%5Cfrac%7B1%7D%7B%5Csqrt%7Bh%7D%20%7D" alt=" \frac{1}{\sqrt{h} }"> ，就可以调整学习的尺度。这意味着， 参数的元素中变动较大（被大幅更新）的元素的学习率将变小。也就是说， 可以按参数的元素进行学习率衰减，使变动大的参数的学习率逐渐减小。</p><blockquote><p>AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为0， 完全不再更新。为了改善这个问题，可以使用<strong>RMSProp</strong>方法。 RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐 地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。 这种操作从专业上讲，称为“指数移动平均”，呈指数函数式地减小 过去的梯度的尺度。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14268853-c2fe52ec70ad0efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>函数的取值高效地向着最小值移动。由于y轴方向上的梯度较大，因此刚开始变动较大，但是后面会根据这个较大的变动按 比例进行调整，减小更新的步伐。因此，y轴方向上的更新程度被减弱，“之” 字形的变动程度明显减弱。</p><h4 id="1-4-Adam"><a href="#1-4-Adam" class="headerlink" title="1.4 Adam"></a>1.4 Adam</h4><p>Momentum参照小球在碗中滚动的物理规则进行移动，AdaGrad为参 数的每个元素适当地调整更新步伐。如果将这两个方法融合在一起会怎么样呢？这就是Adam的基本思路。</p><p>Adam是2015年提出的新方法。它的理论有些复杂，简单地讲，就是融 合了Momentum和AdaGrad的方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。此外，进行超参数（后面会提到）的“偏置校正”也是Adam的特征。 这里不再进行过多的说明，详细内容请参考原作者的论文。</p><blockquote><p>Adam会设置3个超参数。一个是学习率（论文中以α出现），另外两 个是一次momentum系数β1和二次momentum系数β2。根据论文， 标准的设定值是β1为0.9，β2 为0.999。设置了这些值后，大多数情 况下都能顺利运行。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14268853-56193c42a936ea40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>基于Adam的更新过程就像小球在碗中滚动一样。虽然 Momentun也有类似的移动，但是相比之下，Adam的小球左右摇晃的程度 有所减轻。这得益于学习的更新程度被适当地调整了。</p><p>上面我们介绍了SGD、Momentum、AdaGrad、Adam这4种方法，那么用哪种方法好呢？</p><p>非常遗憾，目前并不存在能在所有问题中都表现良好 的方法。这4种方法各有各的特点，都有各自擅长解决的问题和不擅长解决的问题。 很多研究中至今仍在使用SGD。Momentum和AdaGrad也是值得一试的方法，最近也很多研究人员和技术人员都喜欢用Adam。</p><h3 id="2-权重的初始值"><a href="#2-权重的初始值" class="headerlink" title="2. 权重的初始值"></a>2. 权重的初始值</h3><p>在神经网络的学习中，权重的初始值特别重要。实际上，设定什么样的 权重初始值，经常关系到神经网络的学习能否成功。</p><p>后面我们会介绍抑制过拟合、提高泛化能力的技巧——权值衰减（weight decay）。简单地说，权值衰减就是一种以减小权重参数的值为目的进行学习的方法。通过减小权重参数的值来抑制过拟合的发生。 </p><p>如果想减小权重的值，一开始就将初始值设为较小的值才是正途。实际上， 在这之前的权重初始值都是像0.01 * np.random.randn(10, 100)这样，使用由高斯分布生成的值乘以0.01后得到的值（标准差为0.01的高斯分布）。</p><p>如果我们把权重初始值全部设为0以减小权重的值，会怎么样呢？从结论来说，将权重初始值设为0不是一个好主意。事实上，将权重初始值设为0的话，将无法正确进行学习。</p><p>这是因为在误差反向传播法中，所有的权重值都会进行相同的更新。比如，在2层神经网络中，假设第1层和第2层的权重为0。这样一来，正向传播时，因为输入层的权重为0，所以第2层的神经元全部会被传递相同的值。第2层的神经元中全部输入相同的值，这意味着反向传播时第2层的权重全部都会进行相同的更新。因此，权重被更新为相同的值，并拥有了重复的值。 这使得神经网络拥有许多不同的权重的意义丧失了。为了防止“权重均一化” ，必须随机生成初始值。</p><p>接下来我们来看看权重的初值是如何影响隐藏层的激活值的分布的：</p><p>当我们使用标准差为1的高斯分布作为权重初始值时各层的激活值偏向0和1分布，假如使用sigmoid函数，随着输出不断靠近0或1，他的导数值不断接近于0。因此，偏向0和1的数据分布会造成反向传播中梯度的值不断变小，最后消失。这个问题称为<strong>梯度消失</strong>。层次加深的深度学习中，梯度消失的问题可能会更加严重。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-80139955d84be888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>而使用标准差为0.01的高斯分布时，如图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-9d3d7036ab786887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>这次呈集中在0.5附近的分布，因为不像刚才的例子那样偏向0和1，所以不会发生梯度消失的问题。但是，激活值的分布有所偏向，说明在表现力 上会有很大问题。为什么这么说呢？</p><p>因为如果有多个神经元都输出几乎相同 的值，那它们就没有存在的意义了。比如，如果100个神经元都输出几乎相同的值，那么也可以由1个神经元来表达基本相同的事情。因此，激活值在 分布上有所偏向会出现“表现力受限”的问题。</p><h4 id="2-1-Xavier初始值"><a href="#2-1-Xavier初始值" class="headerlink" title="2.1 Xavier初始值"></a>2.1 Xavier初始值</h4><p>Xavier的论文中，为了使各层的激活值呈现出具有相同广度的分布，推导了合适的权重尺度。推导出的结论是，如果前一层的节点数为n，则初始 值使用标准差为<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B%5Csqrt%7Bn%7D%20%7D%20" alt="\frac{1}{\sqrt{n} } ">的分布。使用Xavier初始值后，前一层的节点数越多，要设定为目标节点的初始值的权重尺度就越小。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-7b389a9e46b17b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>使用Xavier初始值后的结果如图6-13所示。从这个结果可知，越是后面的层，图像变得越歪斜，但是呈现了比之前更有广度的分布。因为各层间传递的数据有适当的广度，所以sigmoid函数的表现力不受限制，有望进行高效的学习。</p><p>想了解Xavier初始值是如何推导的，可以看我在网上看到的这篇文章：<a href="https://www.cnblogs.com/hejunlin1992/p/8723816.html" target="_blank" rel="noopener">深度学习中Xavier初始化</a></p><h4 id="2-2-ReLu初始值"><a href="#2-2-ReLu初始值" class="headerlink" title="2.2 ReLu初始值"></a>2.2 ReLu初始值</h4><p>Xavier初始值是以激活函数是线性函数为前提而推导出来的。因为 sigmoid函数和tanh函数左右对称，且中央附近可以视作斜率为1的线性函数，所以适用于Xavier函数。</p><p>但当激活函数使用ReLu时，一般推荐使用“He初始值”，即当前一层的节点数为n时，He初始值使用标准差为<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B%5Csqrt%20%7Bn%7D%7D%20" alt="\frac{1}{\sqrt {n}} ">的高斯分布。当 Xavier初始值是 时，（直观上）可以解释为，因为ReLU的负值区域的值 为0，为了使它更有广度，所以需要2倍的系数。</p><p>接下来我们看看三种情况下的实验结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-f07f4db391c192d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>观察实验结果可知，当“std = 0.01”时，各层的激活值非常小。神经网络上传递的是非常小的值，说明逆向传播时权重的梯度也同样很小，学习基本没有进展。</p><p>接下来是初始值为Xavier初始值时的结果。在这种情况下，随着层的加深， 偏向一点点变大。实际上，层加深后，随着激活值的偏向变大，学习时会出现梯度消失的问题。</p><p>而当初始值为He初始值时，各层中分布的广度相同。由于即便层加深，数据的广度也能保持不变，因此逆向传播时，也会传递合适的值。</p><h3 id="3-Batch-Normalization-批量标准化"><a href="#3-Batch-Normalization-批量标准化" class="headerlink" title="3. Batch Normalization 批量标准化"></a>3. Batch Normalization 批量标准化</h3><p>Batch Normalization（下文简称Batch Norm）是 2015年提出的方法。 Batch Norm虽然是一个问世不久的新方法，但已经被很多研究人员和技术 人员广泛使用。</p><p>Batch Norm有以下优点：</p><p>• 可以使学习快速进行（可以增大学习率）。</p><p>• 不那么依赖初始值（对于初始值不用那么纠结）。 </p><p>• 抑制过拟合（降低<strong>Dropout（一种避免过拟合的方法，后面会提到）</strong>等的必要性）。</p><p>Batch Norm的思路是调整各层的激活值分布使其拥有适当 的广度。为此，要向神经网络中插入对数据分布进行正规化的层，即Batch Normalization层。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-18c2a29e91d073a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Batch Norm，顾名思义，以进行学习时的mini-batch为单位，按mini-batch进行正规化。具体而言，就是进行使数据分布的均值为0、方差为1的正规化。用数学式表示的话，如下所示:</p><p><img src="https://math.jianshu.com/math?formula=%5Cmu%20_B%20%5Cleftarrow%20%20%5Cfrac%20%7B1%7D%20%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5Em%20x_i" alt="\mu _B \leftarrow  \frac {1} {m} \sum_{i=1}^m x_i">         <img src="https://math.jianshu.com/math?formula=%7B%5Csigma%20_B%7D%5E2%20%5Cleftarrow%20%5Cfrac%20%7B1%7D%7Bm%7D%20%5Csum_%7Bi%20%3D%201%7D%5Em%20%7B(x_i%20-%20%5Cmu%20_B)%7D%5E2" alt="{\sigma _B}^2 \leftarrow \frac {1}{m} \sum_{i = 1}^m {(x_i - \mu _B)}^2">          <img src="https://math.jianshu.com/math?formula=%5Chat%7Bx%7D%20_i%20%5Cleftarrow%20%5Cfrac%7Bx_i%20-%20%5Cmu_B%7D%7B%5Csqrt%7B%5Csigma_B%20%5E2%20%2B%20%5Cvarepsilon%20%7D%7D" alt="\hat{x} _i \leftarrow \frac{x_i - \mu_B}{\sqrt{\sigma_B ^2 + \varepsilon }}"></p><p>这里对mini-batch的m个输入数据的集合B ={x1,x2,…,xm}求均值 <img src="https://math.jianshu.com/math?formula=%5Cmu%20_B" alt="\mu _B">和方差<img src="https://math.jianshu.com/math?formula=%7B%5Csigma%20_B%7D%5E2%20" alt="{\sigma _B}^2 "> 。然后，对输入数据进行均值为0、方差为1（合适的分布）的正规化。式子中的<img src="https://math.jianshu.com/math?formula=%5Cvarepsilon%20" alt="\varepsilon ">是一个微小值（比如，10e-7等），它是为了防止出现除以0的情况。</p><p>接着，Batch Norm层会对正规化后的数据进行缩放和平移的变换，用数学式可以如下表示：</p><p><img src="https://math.jianshu.com/math?formula=y_i%3D%20%5Cgamma%20%5Chat%7Bx%7D%20_i%20%2B%20%5Cbeta" alt="y_i= \gamma \hat{x} _i + \beta"></p><p>这里，<img src="https://math.jianshu.com/math?formula=%5Cgamma%20" alt="\gamma ">和<img src="https://math.jianshu.com/math?formula=%5Cbeta%20" alt="\beta ">是参数。一开始<img src="https://math.jianshu.com/math?formula=%5Cgamma%0A" alt="\gamma"> = 1，<img src="https://math.jianshu.com/math?formula=%5Cbeta" alt="\beta"> = 0，然后再通过学习调整到合适的值。 </p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-3e83b4124d581ea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>几乎所有的情况下都是使用Batch Norm时学习进行得更快。 同时也可以发现，在不使用Batch Norm的情况下，如果不赋予一个尺度好的初始值，学习将完全无法进行。通过使用Batch Norm，可以推动学习的进行；并且，神经网络对权重初始值变得健壮。</p><h3 id="4-正则化"><a href="#4-正则化" class="headerlink" title="4.正则化"></a>4.正则化</h3><p>机器学习的问题中，<strong>过拟合</strong>是一个很常见的问题。过拟合指的是只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态。所以，抑制过拟合的技巧很重要。</p><p>发生过拟合的原因，主要有以下两个：</p><p>• 模型拥有大量参数、表现力强。</p><p> • 训练数据少。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-7ad5ca3d56ca41c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="4-1-权值衰减"><a href="#4-1-权值衰减" class="headerlink" title="4.1 权值衰减"></a>4.1 权值衰减</h4><p>权值衰减是一直以来经常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为权重参数取值过大才发生的。 </p><p>神经网络的学习目的是减小损失函数的值。这时，例如为损失函数加上权重的平方范数（L2范数）。这样一来，就可以抑制权重变大。 用符号表示的话，如果将权重记为<img src="https://math.jianshu.com/math?formula=W" alt="W">，L2范数的权值衰减就是<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D%5Clambda%20W%5E2%0A" alt="\frac{1}{2}\lambda W^2"> ，然 后将这个<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D%5Clambda%20W%5E2" alt="\frac{1}{2}\lambda W^2">加到损失函数上。这里，λ是控制正则化强度的超参数。λ 设置得越大，对大的权重施加的惩罚就越重。此外，<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D%5Clambda%20W%5E2" alt="\frac{1}{2}\lambda W^2">开头的<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}">是用于将<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D%5Clambda%20W%5E2" alt="\frac{1}{2}\lambda W^2">的求导结果变成<img src="https://math.jianshu.com/math?formula=%5Clambda%20W" alt="\lambda W">的调整用常量。 对于所有权重，权值衰减方法都会为损失函数加上 。因此，在求权 重梯度的计算中，要为之前的误差反向传播法的结果加上正则化项的导数<img src="https://math.jianshu.com/math?formula=%5Clambda%20W" alt="\lambda W">。</p><blockquote><p>L2范数相当于各个元素的平方和。用数学式表示的话，假设有权重 <img src="https://math.jianshu.com/math?formula=W%20%3D%20%EF%BC%88w_1%2C%20w_2%20...%20%2C%20w_n" alt="W = （w_1, w_2 ... , w_n)">)，则L2范数可用<img src="https://math.jianshu.com/math?formula=L_2%20%3D%20%5Csqrt%20%7Bw_1%5E2%20%2B%20w_2%5E2%20%2B%20....%20%2B%20w_n%5E2%7D" alt="L_2 = \sqrt {w_1^2 + w_2^2 + .... + w_n^2}">计算出来。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/14268853-049cc9266362b730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h4 id="4-2-Dropout"><a href="#4-2-Dropout" class="headerlink" title="4.2 Dropout"></a>4.2 Dropout</h4><p>作为抑制过拟合的方法，前面我们介绍了为损失函数加上权重的L2范数的权值衰减方法。该方法可以简单地实现，在某种程度上能够抑制过拟合。但是，如果网络的模型变得很复杂，只用权值衰减就难以应对了。</p><p>在这种情 况下，我们经常会使用Dropout方法。 Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然使其暂时失效。被删除的神经元不再进行信号的传递。训练时，每传递一次数据，就会随机选择要失效的神经元。 </p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-f42c12b42b8675f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>通过使用Dropout，训练数据和测试数据的识别精度的差距 变小了。并且，训练数据也没有到达100%的识别精度。像这样，通过使用 Dropout，即便是表现力强的网络，也可以抑制过拟合。</p><p><img src="https://upload-images.jianshu.io/upload_images/14268853-32c653fa25b5141a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>机器学习中经常使用集成学习。所谓集成学习，就是让多个模型单 独进行学习，推理时再取多个模型的输出的平均值。实验告诉我们，通过进行集成学习，神经网络的识别精度可以提高好几个百分点。这个集成学习与Dropout有密切的关系。</p><p>这是因为可以将Dropout 理解为，通过在学习过程中随机删除神经元，从而每一次都让不同的模型进行学习。并且，推理时，通过对神经元的输出乘以删除比例（比如，0.5等），可以取得模型的平均值。也就是说，可以理解成， Dropout将集成学习的效果通过一个网络实现了。</p></blockquote><h4 id="4-3-超参数验证"><a href="#4-3-超参数验证" class="headerlink" title="4.3 超参数验证"></a>4.3 超参数验证</h4><p>神经网络中，除了权重和偏置等参数，超参数（hyper-parameter）也经常出现。这里所说的超参数是指，比如各层的神经元数量、batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。</p><p>之前我们使用的数据集分成了训练数据和测试数据，训练数据用于学习， 测试数据用于评估泛化能力。调整超参数时，必须使用超参数专用的确认数据。用于调整超参数的数据，一般称为验证数据（validation data）。我们使用这个验证数据来 评估超参数的好坏。</p><p>进行超参数的最优化时，逐渐缩小超参数的“好值”的存在范围非常重要。 所谓逐渐缩小范围，是指一开始先大致设定一个范围，从这个范围中随机选 出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。 通过重复这一操作，就可以逐渐确定超参数的合适范围。</p><p>超参数的范围只要“大致地指定”就可以了，也就是像0.001（<img src="https://math.jianshu.com/math?formula=10%5E%7B-3%7D" alt="10^{-3}">）到 1000（<img src="https://math.jianshu.com/math?formula=10%5E3" alt="10^3">）这样，以“ 10的阶乘”的尺度指定范围。 </p><p>在超参数的最优化中，要注意的是深度学习需要很长时间（比如，几天或几周）。因此，在超参数的搜索中，需要尽早放弃那些不符合逻辑的超参数。 在最优化中，减少学习的epoch，缩短一次评估所需的时间 是一个不错的办法。 简单归纳一下，如下所示:</p><p><strong>步骤0</strong>     <strong>设定超参数的范围。</strong></p><p><strong>步骤1</strong>     <strong>从设定的超参数范围中随机采样。</strong></p><p><strong>步骤2</strong>     <strong>使用步骤1中采样到的超参数的值进行学习，通过验证数据评估识别精度（但是要将epoch设置得很小）。</strong></p><p><strong>步骤3</strong>     <strong>重复步骤1和步骤2（100次等），根据它们的识别精度的结果，缩小超参数的范围。</strong></p><p>反复进行上述操作，不断缩小超参数的范围，在缩小到一定程度时，从该范围中选出一个超参数的值。这就是进行超参数的最优化的一种方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从感知机到神经网络&quot;&gt;&lt;a href=&quot;#从感知机到神经网络&quot; class=&quot;headerlink&quot; title=&quot;从感知机到神经网络&quot;&gt;&lt;/a&gt;从感知机到神经网络&lt;/h1&gt;&lt;h2 id=&quot;一、感知机&quot;&gt;&lt;a href=&quot;#一、感知机&quot; class=&quot;header
      
    
    </summary>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python入门</title>
    <link href="http://yoursite.com/2019/08/30/Python%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/08/30/Python入门/</id>
    <published>2019-08-30T14:55:58.000Z</published>
    <updated>2019-08-30T15:04:51.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一周学习——Python环境搭建及基本数据类型"><a href="#第一周学习——Python环境搭建及基本数据类型" class="headerlink" title="第一周学习——Python环境搭建及基本数据类型"></a>第一周学习——Python环境搭建及基本数据类型</h1><h2 id="1-Pyhton环境搭建"><a href="#1-Pyhton环境搭建" class="headerlink" title="1.Pyhton环境搭建"></a>1.Pyhton环境搭建</h2><p><strong>以下为Windows系统（相信Linux大佬一定是会装的）</strong></p><ul><li>打开Web浏览器，访问Python安装包官网下载地址：<a href="https://link.jianshu.com/?t=https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></li><li>双击安装，一路next，在【选择路径】的步骤，把选好的路径复制黏贴下来，后面的配置要用到。</li><li>配置环境变量<br>(1) 【计算机】-【属性】-【高级系统设置】-【高级】-【环境变量】-【系统变量】-【Path】<br>(2)  编辑【Path】变量：把刚才复制的安装路径，加到它的结尾，要用英文分号和前面已有的内容隔开。<br>(3)  一路【确定】，完成。</li><li>检查是否安装成功<br>(1) 按键【Win】+【R】- 输入cmd - 打开命令行窗口<br>(2) 输入python - 【Enter】，显示Python版本信息，即安装成功。</li></ul><h2 id="2-Python中的基本数据类型"><a href="#2-Python中的基本数据类型" class="headerlink" title="2.Python中的基本数据类型"></a>2.Python中的基本数据类型</h2><h3 id="一、number类型"><a href="#一、number类型" class="headerlink" title="一、number类型"></a>一、number类型</h3><p>Python3 支持 <code>int</code>、<code>float</code>、<code>bool</code>、<code>complex</code>（复数）。</p><p>在Python 3里，只有一种整数类型 <code>int</code>，表示为长整型(-2^63-2^63)，没有 python2 中的 <code>Long</code></p><h4 id="1-int类型"><a href="#1-int类型" class="headerlink" title="1. int类型"></a>1. int类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">int</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">int</span><span class="params">([x])</span> -&gt; integer</span></span><br><span class="line"><span class="class"> |  int(x, base=10) -&gt; integer</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Convert a number or string to an integer, or return 0 if no arguments</span></span><br><span class="line"><span class="class"> |  are given.  If x is a number, return x.__int__().  For floating point</span></span><br><span class="line"><span class="class"> |  numbers, this truncates towards zero.</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  If x is not a number or if base is given, then x must be a string,</span></span><br><span class="line"><span class="class"> |  bytes, or bytearray instance representing an integer literal in the</span></span><br><span class="line"><span class="class"> |  given base.  The literal can be preceded by '+' or '-' and be surrounded</span></span><br><span class="line"><span class="class"> |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.</span></span><br><span class="line"><span class="class"> |  Base 0 means to interpret the base from the string as an integer literal.</span></span><br><span class="line"><span class="class"> |  &gt;&gt;&gt; int('0b100', base=0)</span></span><br><span class="line"><span class="class"> |  4</span></span><br><span class="line"><span class="class">    .....</span></span><br></pre></td></tr></table></figure><p>可知，创建 <code>int</code> 值有两种方式：</p><ul><li>直接赋予变量整数值</li><li>使用构造器 <code>int()</code> 创建 <code>int</code> 类型实例</li></ul><p>针对第二种方式，如果没有任何输入参数，那么创建 <code>int</code> 实例值为 <code>0</code></p><p>如果仅输入单个对象，可以输入一个数字，或者一个数字字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(‘<span class="number">122</span>’)</span><br><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure><p>int()函数可以把实数类型转换为整数，并且是向下取整，也就是在数轴上向左取整</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">3.6</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">3.4</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>可选参数 <code>base</code> 表示第一个参数值所属进制，默认为 <code>10</code>，表示输入值为十进制数，取值范围为 <code>0</code> 和 <code>[2, 36]</code></p><p>如果输入多个对象，即需要定义输入值的进制时，输入值类型应该为字符串 <code>str</code></p><p>在所有的进制中，<code>2-进制</code>，<code>8-进制</code> 和 <code>16-进制</code> 可以通过添加前缀 <code>0b/0B, 0o/0O，0x/0X</code> 的方式进行转换：</p><p>假如你想要通过调用init来进行有前缀的进制转换，则必须将<code>base</code>设置为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'3333'</span>)</span><br><span class="line"><span class="number">3333</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'3333'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">3333</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0o333'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">219</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0x3333'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">13107</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如不将base设置为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0x3333'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'0x3333'</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0x2676'</span>,<span class="number">8</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">8</span>: <span class="string">'0x2676'</span></span><br></pre></td></tr></table></figure><h4 id="2-float类型"><a href="#2-float类型" class="headerlink" title="2.float类型"></a>2.float类型</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">float</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">float</span><span class="params">(x=<span class="number">0</span>, /)</span></span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"> |  Convert a string or number to a floating point number, if possible.</span><br></pre></td></tr></table></figure><p>浮点型（<code>float</code>）等同于 C 语言中的 <code>double</code> 类型</p><p>创建 <code>float</code> 值有两种方式：</p><ul><li><p>直接赋予变量整数值</p></li><li><p>使用构造器 float() 创建 <code>float</code> 类型实例</p><p>使用第一种方式，如果该数值没有小数，需要添加后缀 .0，否则，解释器会认为这是 int 类型数值，示例如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; a = 33.0</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">float</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>使用第二种方式，如果没有任何输入参数，那么创建 <code>float</code> 实例值为 <code>0.0</code></p><p>也可以输入单个参数，一个数值或者一个数字字符串，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>float()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = float(<span class="number">33</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = float(<span class="string">'222.3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">222.3</span></span><br></pre></td></tr></table></figure><p><strong>使用 float() 构造器还可以定义无穷大（Infinity 或者 inf）和无穷小</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = float(<span class="string">"inf"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = float(<span class="string">"-inf"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">-inf</span><br></pre></td></tr></table></figure><p>为了测试这些值的存在，使用 <code>math.isinf()</code> 进行判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isinf(a)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isinf(b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>无穷大数在执行数学计算的时候会传播</strong></p><p>这个就类似于数学中讲述的，无穷大加上一个常数还是无穷大，无穷大与无穷大相等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + <span class="number">45</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * <span class="number">10</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> / a</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">"inf"</span>) == float(<span class="string">"inf"</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>无穷大在比较中比任何一个数都要大。</p><p><em>问题：但如果我们将无穷大与无穷小相加呢？</em></p><p>有些操作时未定义的并会返回一个 <code>NaN</code> 结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a/a</span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = float(<span class="string">'-inf'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line">nan</span><br></pre></td></tr></table></figure><p><code>nan</code> 值在所有操作中也会传播，并且不会产生异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = float(<span class="string">'nan'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c + <span class="number">23</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c / <span class="number">2</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c * <span class="number">2</span></span><br><span class="line">nan</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.sqrt(c)</span><br><span class="line">nan</span><br></pre></td></tr></table></figure><p>使用 <code>math.isnan()</code> 可以判断值是否是 <code>NaN</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isnan(c)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><code>nan</code> 值的任何比较操作都是返回 <code>False</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">"nan"</span>) == float(<span class="string">"nan"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c &gt; <span class="number">3</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>更安全的类型转换</strong></p><p>由于无穷的存在，因此字符串装浮点数就存在的一些例外，并且这个转换过程不会抛出异常。如果程序员们想改变 python 的默认行为，可以使用 <code>fpectl</code> 模块，但是它在标准的Python 构建中并没有被启用。还有一个比较简单的转换，就是加一个 <code>isdigit()</code> 判断（用于检测字符串是否仅有数字组成）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2float</span><span class="params">(ss)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ss.isdigit():</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> float(ss)</span><br><span class="line">    </span><br><span class="line">sss = <span class="string">"inf"</span></span><br><span class="line"></span><br><span class="line">a = str2float(sss)</span><br></pre></td></tr></table></figure><h4 id="3-bool类型"><a href="#3-bool类型" class="headerlink" title="3.bool类型"></a>3.bool类型</h4><p>Python中的布尔类型有两个常量True和False表示。</p><h6 id="布尔值转化"><a href="#布尔值转化" class="headerlink" title="布尔值转化"></a>布尔值转化</h6><p>Python中的布尔值是可以转化为数值的，True表示1，而False表示0，可以对其进行数值运算，但不建议这么做，会引起代码的混乱。</p><h6 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h6><p>在Python中所有的对象都可以进行真值测试，下面罗列一下判断为假的情况：</p><ul><li>None</li><li>False</li><li>数值中的零，包括0，0.0，0j（虚数）</li><li>空序列，包括空字符串(”)，空元组(())，空列表([])</li><li>空的字典{}</li><li>自定义的对象的实例，该对象的<strong>bool</strong>方法返回False或者<strong>len</strong>方法返回0</li><li>除了以上的情况外，所有的对象在if或者while语句中的表现都为真。</li></ul><h6 id="布尔操作"><a href="#布尔操作" class="headerlink" title="布尔操作"></a>布尔操作</h6><p>在Python中布尔值可以进行或、且、否三种操作，与很多语言不同的是，Python中不是用符号，而是用英文单词来表示，分别是or、and和not。</p><p>需要注意的是or和and都支持短路操作，如果or的左边返回True，则右边就不会判断；同理如果and左边返回False，右边也不会进行判断。</p><p>not的优先级很低，not a == b表示的是not (a == b)，而表达式a == not b会直接报错，需要加括号a == (not b)。</p><h6 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h6><p>通过比较操作会返回布尔类型的值。除了普通的比较操作外，Python还支持is操作来判断两个对象是否是同一个对象，下面是Python支持的所有的比较操作：</p><table><thead><tr><th>操作符</th><th>解释</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>is</td><td>是相同对象</td></tr><tr><td>is not</td><td>是不同对象</td></tr></tbody></table><p>其他操作比较常见，给出一些is的用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line"><span class="comment"># True，因为None只有唯一实例</span></span><br><span class="line">r = a <span class="keyword">is</span> b</span><br><span class="line"></span><br><span class="line">a = <span class="string">"22"</span></span><br><span class="line">b = <span class="string">"22"</span></span><br><span class="line"><span class="comment"># True，直接声明的相同字符串也会指向同一个实例</span></span><br><span class="line">r = a <span class="keyword">is</span> b</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line">b = [<span class="number">1</span>]</span><br><span class="line"><span class="comment"># False，相等但不是同一个实例</span></span><br><span class="line">r = a <span class="keyword">is</span> b</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line"><span class="comment"># True，指向同一个实例</span></span><br><span class="line">r = b <span class="keyword">is</span> c</span><br></pre></td></tr></table></figure><h4 id="4-complex类型"><a href="#4-complex类型" class="headerlink" title="4.complex类型"></a>4.complex类型</h4><p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p><h4 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h4><table><thead><tr><th align="left">算术运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">/</td><td align="left">除 - x除以y</td><td align="left">b / a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">//</td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left">&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</td></tr></tbody></table><table><thead><tr><th align="left">比较运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a == b) 返回 False。</td></tr><tr><td align="left">!=</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a != b) 返回 true.</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a &lt;&gt; b) 返回 true。这个运算符类似 != 。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。</td><td align="left">(a &lt; b) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于    - 返回x是否大于等于y。</td><td align="left">(a &gt;= b) 返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于 -    返回x是否小于等于y。</td><td align="left">(a &lt;= b) 返回 true。</td></tr></tbody></table><table><thead><tr><th align="left">赋值运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c *<em>= a 等效于 c = c *</em> a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr></tbody></table><table><thead><tr><th align="left">位运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。<strong>~x</strong> 类似于 <strong>-x-1</strong></td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移动运算符：运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td><td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，<strong>&gt;&gt;</strong> 右边的数字指定了移动的位数</td><td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><table><thead><tr><th align="left">赋值运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符</td><td align="left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+=</td><td align="left">加法赋值运算符</td><td align="left">c += a 等效于 c = c + a</td></tr><tr><td align="left">-=</td><td align="left">减法赋值运算符</td><td align="left">c -= a 等效于 c = c - a</td></tr><tr><td align="left">*=</td><td align="left">乘法赋值运算符</td><td align="left">c *= a 等效于 c = c * a</td></tr><tr><td align="left">/=</td><td align="left">除法赋值运算符</td><td align="left">c /= a 等效于 c = c / a</td></tr><tr><td align="left">%=</td><td align="left">取模赋值运算符</td><td align="left">c %= a 等效于 c = c % a</td></tr><tr><td align="left">**=</td><td align="left">幂赋值运算符</td><td align="left">c *<em>= a 等效于 c = c *</em> a</td></tr><tr><td align="left">//=</td><td align="left">取整除赋值运算符</td><td align="left">c //= a 等效于 c = c // a</td></tr></tbody></table><h3 id="二、字符串类型"><a href="#二、字符串类型" class="headerlink" title="二、字符串类型"></a>二、字符串类型</h3><h4 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1.字符串拼接"></a>1.字符串拼接</h4><h6 id="1、来自C语言的-方式"><a href="#1、来自C语言的-方式" class="headerlink" title="1、来自C语言的%方式"></a>1、来自C语言的%方式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'%s %s'</span> % (<span class="string">'Hello'</span>, <span class="string">'world'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello world</span><br></pre></td></tr></table></figure><p>%号格式化字符串的方式继承自古老的C语言，这在很多编程语言都有类似的实现。上例的%s是一个占位符，它仅代表一段字符串，并不是拼接的实际内容。实际的拼接内容在一个单独的%号后面，放在一个元组里。</p><p>类似的占位符还有：%d（代表一个整数）、%f（代表一个浮点数）、%x（代表一个16进制数），等等。%占位符既是这种拼接方式的特点，同时也是其限制，因为每种占位符都有特定意义，实际使用起来太麻烦了。</p><h6 id="2、format-拼接方式"><a href="#2、format-拼接方式" class="headerlink" title="2、format()拼接方式"></a>2、format()拼接方式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简洁版</span></span><br><span class="line">s1 = <span class="string">'Hello &#123;&#125;! My name is &#123;&#125;.'</span>.format(<span class="string">'World'</span>, <span class="string">'Python猫'</span>)</span><br><span class="line">print(s1)</span><br><span class="line">&gt;&gt;&gt;Hello World! My name <span class="keyword">is</span> Python猫.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对号入座版</span></span><br><span class="line">s2 = <span class="string">'Hello &#123;0&#125;! My name is &#123;1&#125;.'</span>.format(<span class="string">'World'</span>, <span class="string">'Python猫'</span>)</span><br><span class="line">s3 = <span class="string">'Hello &#123;name1&#125;! My name is &#123;name2&#125;.'</span>.format(name1=<span class="string">'World'</span>, name2=<span class="string">'Python猫'</span>)</span><br><span class="line">print(s2)</span><br><span class="line">&gt;&gt;&gt;Hello World! My name <span class="keyword">is</span> Python猫.</span><br><span class="line">print(s3)</span><br><span class="line">&gt;&gt;&gt;Hello World! My name <span class="keyword">is</span> Python猫.</span><br></pre></td></tr></table></figure><p>这种方式使用花括号{}做占位符，在format方法中再转入实际的拼接值。容易看出，它实际上是对%号拼接方式的改进。这种方式在Python2.6中开始引入。</p><p>上例中，简洁版的花括号中无内容，缺点是容易弄错次序。对号入座版主要有两种，一种传入序列号，一种则使用key-value的方式，更加直观。</p><h6 id="3、直接拼接"><a href="#3、直接拼接" class="headerlink" title="3、直接拼接"></a>3、直接拼接</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s_tuple = (<span class="string">'Hello'</span>, <span class="string">' '</span>, <span class="string">'world'</span>)</span><br><span class="line">s_like_tuple = (<span class="string">'Hello'</span> <span class="string">' '</span> <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">print(s_tuple) </span><br><span class="line">&gt;&gt;&gt;(<span class="string">'Hello'</span>, <span class="string">' '</span>, <span class="string">'world'</span>)</span><br><span class="line">print(s_like_tuple) </span><br><span class="line">&gt;&gt;&gt;Hello world</span><br><span class="line"></span><br><span class="line">type(s_like_tuple) &gt;&gt;&gt;str</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多元素时，不支持有变量</span></span><br><span class="line">str_1 = <span class="string">'Hello'</span></span><br><span class="line">str_2 = (str_1 <span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SyntaxError: invalid syntax</span><br><span class="line">str_3 = (str_1 str_1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SyntaxError: invalid syntax</span><br><span class="line"><span class="comment"># 但是下面写法不会报错</span></span><br><span class="line">str_4 = (str_1)</span><br></pre></td></tr></table></figure><h6 id="4、面向对象模板拼接"><a href="#4、面向对象模板拼接" class="headerlink" title="4、面向对象模板拼接"></a>4、面向对象模板拼接</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line">s = Template(<span class="string">'$&#123;s1&#125; $&#123;s2&#125;!'</span>) </span><br><span class="line">print(s.safe_substitute(s1=<span class="string">'Hello'</span>,s2=<span class="string">'world'</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello world!</span><br></pre></td></tr></table></figure><p>这种方法就十分麻烦且不优雅了</p><h6 id="5、常用的-号方式"><a href="#5、常用的-号方式" class="headerlink" title="5、常用的+号方式"></a>5、常用的+号方式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str_1 = <span class="string">'Hello world！ '</span> </span><br><span class="line">str_2 = <span class="string">'My name is Python猫.'</span></span><br><span class="line">print(str_1 + str_2)</span><br><span class="line">&gt;&gt;&gt;Hello world！ My name <span class="keyword">is</span> Python猫.</span><br><span class="line">print(str_1)</span><br><span class="line">&gt;&gt;&gt;Hello world！</span><br></pre></td></tr></table></figure><p>这种方式最常用、直观、易懂，是入门级的实现方式。但是，它也存在两处让人容易犯错的地方。</p><p>字符串是不可变类型，新的字符串会独占一块新的内存，而原来的字符串保持不变。上例中，拼接前有两段字符串，拼接后实际有三段字符串。</p><p>有种说法是当拼接次数不超过3时，使用+号连接符就会比其它方式快（ps：不少Python教程都是如此建议），但这没有任何合理根据。</p><p>事实上，在拼接短的字面值时，由于CPython中的 <code>常数折叠</code> （constant folding）功能，这些字面值会被转换成更短的形式，例如’a’+’b’+’c’ 被转换成’abc’，’hello’+’world’也会被转换成’hello world’。这种转换是在编译期完成的，而到了运行期时就不会再发生任何拼接操作，因此会加快整体计算的速度。</p><p>常数折叠优化有一个限度，它要求拼接结果的长度不超过20。所以，<strong>当拼接的最终字符串长度不超过20时，+号操作符的方式，会比后面提到的join等方式快得多，这与+号的使用次数无关。</strong></p><h6 id="6、join-拼接方式"><a href="#6、join-拼接方式" class="headerlink" title="6、join()拼接方式"></a>6、join()拼接方式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str_list = [<span class="string">'Hello'</span>, <span class="string">'world'</span>]</span><br><span class="line">str_join1 = <span class="string">' '</span>.join(str_list)</span><br><span class="line">str_join2 = <span class="string">'-'</span>.join(str_list)</span><br><span class="line">print(str_join1) &gt;&gt;&gt;Hello world</span><br><span class="line">print(str_join2) &gt;&gt;&gt;Hello-world</span><br></pre></td></tr></table></figure><p>str对象自带的join()方法，接受一个序列参数，可以实现拼接。拼接时，元素若不是字符串，需要先转换一下。可以看出，这种方法比较适用于连接序列对象中（例如列表）的元素，并设置统一的间隔符。</p><p>当拼接长度超过20时，这种方式基本上是首选。不过，它的缺点就是，不适合进行零散片段的、不处于序列集合的元素拼接。</p><h6 id="7、f-string方式"><a href="#7、f-string方式" class="headerlink" title="7、f-string方式"></a>7、f-string方式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'world'</span></span><br><span class="line">myname = <span class="string">'python_cat'</span></span><br><span class="line">words = <span class="string">f'Hello <span class="subst">&#123;name&#125;</span>. My name is <span class="subst">&#123;myname&#125;</span>.'</span></span><br><span class="line">print(words)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello world. My name <span class="keyword">is</span> python_cat.</span><br></pre></td></tr></table></figure><p>f-string方式出自PEP 498<code>Literal String Interpolation</code>，从Python3.6版本引入。其特点是在字符串前加 f 标识，字符串中间则用花括号{}包裹其它字符串变量。</p><p>这种方式在可读性上秒杀format()方式，处理长字符串的拼接时，速度与join()方法相当。</p><p>总结一下，我们前面说的“字符串拼接”，其实是从结果上理解。若从实现原理上划分的话，我们可以将这些方法划分出三种类型：</p><ul><li>格式化类：%、format()、template</li><li>拼接类：+、()、join()</li><li>插值类：f-string</li></ul><h4 id="2-切片"><a href="#2-切片" class="headerlink" title="2.切片"></a>2.切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str[beg:end]</span></span><br><span class="line"><span class="comment"># （下标从 0 开始）从下标为beg开始算起，切取到下标为 end-1 的元素，切取的区间为 [beg, end)</span></span><br><span class="line">str = <span class="string">' python str '</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">3</span>:<span class="number">6</span>]    <span class="comment"># tho</span></span><br><span class="line"><span class="comment"># str[beg:end:step]</span></span><br><span class="line"><span class="comment"># 取 [beg, end) 之间的元素，每隔 step 个取一个</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]  <span class="comment"># yhn</span></span><br></pre></td></tr></table></figure><h4 id="3-原始字符串"><a href="#3-原始字符串" class="headerlink" title="3.原始字符串"></a>3.原始字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在字符串前加 r/R</span></span><br><span class="line"><span class="comment"># 所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">r'\n'</span>   <span class="comment"># \n</span></span><br></pre></td></tr></table></figure><h4 id="4-字符串重复"><a href="#4-字符串重复" class="headerlink" title="4.字符串重复"></a>4.字符串重复</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str * n, n * str</span></span><br><span class="line"><span class="comment"># n 为一个 int 数字</span></span><br><span class="line">str = <span class="string">"hi"</span></span><br><span class="line"><span class="keyword">print</span> str*<span class="number">2</span>   <span class="comment"># hihi</span></span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>*str   <span class="comment"># hihi</span></span><br></pre></td></tr></table></figure><h4 id="5-in"><a href="#5-in" class="headerlink" title="5.in"></a>5.in</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">' python'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'p'</span> <span class="keyword">in</span> str    <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'py'</span> <span class="keyword">in</span> str   <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'py'</span> <span class="keyword">not</span> <span class="keyword">in</span> str <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h4 id="6-字符串常用函数"><a href="#6-字符串常用函数" class="headerlink" title="6.字符串常用函数"></a>6.字符串常用函数</h4><h5 id="去空格"><a href="#去空格" class="headerlink" title="去空格"></a>去空格</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">' python str '</span></span><br><span class="line"><span class="keyword">print</span> str</span><br><span class="line"><span class="comment"># 去首尾空格</span></span><br><span class="line"><span class="keyword">print</span> str.strip()</span><br><span class="line"><span class="comment"># 去左侧空格</span></span><br><span class="line"><span class="keyword">print</span> str.lstrip()</span><br><span class="line"><span class="comment"># 去右侧空格</span></span><br><span class="line"><span class="keyword">print</span> str.rstrip()</span><br></pre></td></tr></table></figure><h5 id="分隔字符串"><a href="#分隔字符串" class="headerlink" title="分隔字符串"></a>分隔字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">' 1 , 2 , 3 , 4 , 5 , '</span></span><br><span class="line"><span class="comment"># 默认使用空格分隔</span></span><br><span class="line"><span class="keyword">print</span> str.split()   <span class="comment"># ['1', ',', '2', ',', '3', ',', '4', ',', '5', ',']</span></span><br><span class="line"><span class="comment"># 指定使用空格进行分隔，首尾如果有空格，则会出现在结果中</span></span><br><span class="line"><span class="keyword">print</span> str.split(<span class="string">' '</span>) <span class="comment"># ['', '1', ',', '2', ',', '3', ',', '4', ',', '5', ',', '']</span></span><br><span class="line"><span class="comment"># 指定其他字符串进行分隔</span></span><br><span class="line"><span class="keyword">print</span> str.split(<span class="string">','</span>) <span class="comment"># [' 1 ', ' 2 ', ' 3 ', ' 4 ', ' 5 ', ' ']</span></span><br><span class="line"><span class="keyword">print</span> str.split(<span class="string">'3 ,'</span>) <span class="comment"># [' 1 , 2 , ', ' 4 , 5 , ']</span></span><br><span class="line">str = <span class="string">'mississippi'</span></span><br><span class="line"><span class="keyword">print</span> str.rstrip(<span class="string">'ip'</span>)</span><br><span class="line"><span class="comment"># 取行, python 中把 "\r"，"\n"，"\r\n"，作为行分隔符</span></span><br><span class="line">str = <span class="string">'ab c\n\nde fg\rkl\r\n'</span></span><br><span class="line"><span class="keyword">print</span> str.splitlines()      <span class="comment"># ['ab c', '', 'de fg', 'kl']</span></span><br><span class="line"><span class="keyword">print</span> str.splitlines(<span class="literal">True</span>)  <span class="comment"># ['ab c\n', '\n', 'de fg\r', 'kl\r\n']</span></span><br></pre></td></tr></table></figure><h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串。</span></span><br><span class="line">str = <span class="string">'-'</span></span><br><span class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="comment"># 字符串序列</span></span><br><span class="line"><span class="keyword">print</span> str.join(seq)  <span class="comment"># 'a-b-c'</span></span><br></pre></td></tr></table></figure><h5 id="统计字符串里某个字符出现的次数"><a href="#统计字符串里某个字符出现的次数" class="headerlink" title="统计字符串里某个字符出现的次数"></a>统计字符串里某个字符出现的次数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.count(sub, start= 0,end=len(string))</span></span><br><span class="line">str = <span class="string">"thing example....wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> str.count(<span class="string">'i'</span>, <span class="number">0</span>, <span class="number">5</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">print</span> str.count(<span class="string">'e'</span>)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h5 id="检测字符串中是否包含子字符串"><a href="#检测字符串中是否包含子字符串" class="headerlink" title="检测字符串中是否包含子字符串"></a>检测字符串中是否包含子字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.find(str, beg=0, end=len(string))</span></span><br><span class="line"><span class="comment"># 如果包含子字符串返回开始的索引值，否则返回-1。</span></span><br><span class="line">str1 = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line">str2 = <span class="string">"exam"</span></span><br><span class="line"><span class="keyword">print</span> str1.find(str2)      <span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.find(str2, <span class="number">10</span>)  <span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.find(str2, <span class="number">40</span>)  <span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.index(str, beg=0, end=len(string))</span></span><br><span class="line"><span class="comment"># 如果包含子字符串返回开始的索引值，否则抛出异常。</span></span><br><span class="line"><span class="keyword">print</span> str1.index(str2)     <span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.index(str2, <span class="number">10</span>) <span class="comment"># 15</span></span><br><span class="line"><span class="keyword">print</span> str1.index(str2, <span class="number">40</span>)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "test.py", line 8, in</span></span><br><span class="line"><span class="comment">#   print str1.index(str2, 40);</span></span><br><span class="line"><span class="comment">#   ValueError: substring not found</span></span><br><span class="line"><span class="comment"># shell returned 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.rfind(str, beg=0, end=len(string))</span></span><br><span class="line"><span class="comment"># str.rindex(str, beg=0, end=len(string))</span></span><br></pre></td></tr></table></figure><h5 id="判断字符串是否以指定前缀、后缀结尾"><a href="#判断字符串是否以指定前缀、后缀结尾" class="headerlink" title="判断字符串是否以指定前缀、后缀结尾"></a>判断字符串是否以指定前缀、后缀结尾</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.startswith(str, beg=0,end=len(string))</span></span><br><span class="line"><span class="comment"># 检查字符串以指定子字符串开头，如果是则返回 True，否则返回 False</span></span><br><span class="line">str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> str.startswith( <span class="string">'this'</span> );       <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> str.startswith( <span class="string">'is'</span>, <span class="number">2</span>, <span class="number">4</span> )    <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> str.startswith( <span class="string">'this'</span>, <span class="number">2</span>, <span class="number">4</span> )  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.endswith(suffix[, start[, end]])</span></span><br><span class="line"><span class="comment"># 以指定后缀结尾返回True，否则返回False</span></span><br><span class="line">suffix = <span class="string">"wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> str.endswith(suffix);         <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> str.endswith(suffix,<span class="number">20</span>);      <span class="comment"># True</span></span><br><span class="line">suffix = <span class="string">"is"</span>;</span><br><span class="line"><span class="keyword">print</span> str.endswith(suffix, <span class="number">2</span>, <span class="number">4</span>);   <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> str.endswith(suffix, <span class="number">2</span>, <span class="number">6</span>);   <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h5 id="根据指定的分隔符将字符串进行分割"><a href="#根据指定的分隔符将字符串进行分割" class="headerlink" title="根据指定的分隔符将字符串进行分割"></a>根据指定的分隔符将字符串进行分割</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.partition(del)</span></span><br><span class="line"><span class="comment"># 返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串。</span></span><br><span class="line">str = <span class="string">"http://www.baidu.com/"</span></span><br><span class="line"><span class="keyword">print</span> str.partition(<span class="string">"://"</span>)   <span class="comment"># ('http', '://', 'www.baidu.com/')</span></span><br><span class="line"><span class="comment"># string.rpartition(str)   从右边开始</span></span><br></pre></td></tr></table></figure><h5 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.replace(old, new[, max])</span></span><br><span class="line"><span class="comment"># 字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</span></span><br><span class="line">str = <span class="string">"thing example....wow!!! thisslly string"</span>;</span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>);     <span class="comment"># thwas was string example....wow!!! thwas was really string</span></span><br><span class="line"><span class="keyword">print</span> str.replace(<span class="string">"is"</span>, <span class="string">"was"</span>, <span class="number">3</span>);  <span class="comment"># thwas was string example....wow!!! thwas is really string</span></span><br><span class="line"><span class="comment"># str.expandtabs(tabsize=8)</span></span><br><span class="line"><span class="comment"># 把字符串中的 tab 符号('\t')转为空格，tab 符号('\t')默认的空格数是 8</span></span><br></pre></td></tr></table></figure><h5 id="检测字符串组成"><a href="#检测字符串组成" class="headerlink" title="检测字符串组成"></a>检测字符串组成</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测数字</span></span><br><span class="line">str.isdigit()    <span class="comment"># 检测字符串是否只由数字组成</span></span><br><span class="line">str.isnumeric()  <span class="comment"># 检测字符串是否只由数字组成,这种方法是只针对unicode对象</span></span><br><span class="line">str.isdecimal()  <span class="comment"># 检查字符串是否只包含十进制字符。这种方法只存在于unicode对象</span></span><br><span class="line"><span class="comment"># 检测字母</span></span><br><span class="line">str.isalpha()   <span class="comment"># 检测字符串是否只由字母组成</span></span><br><span class="line"><span class="comment"># 检测字母和数字</span></span><br><span class="line">str.isalnum()   <span class="comment"># 检测字符串是否由字母和数字组成</span></span><br><span class="line"><span class="comment"># 检测其他</span></span><br><span class="line">str.isspace()   <span class="comment"># 检测字符串是否只由空格组成</span></span><br><span class="line">str.islower()   <span class="comment"># 检测字符串是否由小写字母组成</span></span><br><span class="line">str.isupper()   <span class="comment"># 检测字符串中所有的字母是否都为大写</span></span><br><span class="line">str.istitle()   <span class="comment"># 检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写</span></span><br></pre></td></tr></table></figure><h5 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str.capitalize()   <span class="comment"># 将字符串的第一个字母变成大写,其他字母变小写</span></span><br><span class="line">str.lower()        <span class="comment"># 转换字符串中所有大写字符为小写</span></span><br><span class="line">str.upper()        <span class="comment"># 将字符串中的小写字母转为大写字母</span></span><br><span class="line">str.swapcase()     <span class="comment"># 对字符串的大小写字母进行转换</span></span><br><span class="line">max(str)    <span class="comment"># 返回字符串 str 中最大的字母</span></span><br><span class="line">min(str)    <span class="comment"># 返回字符串 str 中最小的字母</span></span><br><span class="line">len(str)    <span class="comment"># 返回字符串的长度</span></span><br><span class="line">str(arg) <span class="comment"># 将 arg 转换为 string</span></span><br></pre></td></tr></table></figure><h4 id="7-格式化输出"><a href="#7-格式化输出" class="headerlink" title="7.格式化输出"></a>7.格式化输出</h4><h5 id="居中填充"><a href="#居中填充" class="headerlink" title="居中填充"></a>居中填充</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.center(width[, fillchar])</span></span><br><span class="line"><span class="comment"># 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格</span></span><br><span class="line">str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> str.center(<span class="number">40</span>, <span class="string">'a'</span>)   <span class="comment"># aaaathis is string  example....wow!!!aaaa</span></span><br></pre></td></tr></table></figure><h5 id="靠右填充"><a href="#靠右填充" class="headerlink" title="靠右填充"></a>靠右填充</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.zfill(width)</span></span><br><span class="line"><span class="comment"># 返回指定长度的字符串，原字符串右对齐，前面填充0</span></span><br><span class="line">str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> str.zfill(<span class="number">40</span>)   <span class="comment"># 00000000this is string example....wow!!!</span></span><br></pre></td></tr></table></figure><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"My name is %s and weight is %d kg!"</span> % (<span class="string">'Zara'</span>, <span class="number">21</span>)</span><br><span class="line"><span class="comment"># My name is Zara and weight is 21 kg!</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'%(language)s has %(number)03d quote types.'</span> % &#123;<span class="string">"language"</span>: <span class="string">"Python"</span>, <span class="string">"number"</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># Python has 002 quote types.</span></span><br><span class="line"><span class="comment"># str.format(*args, **kwargs)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0&#125;, &#123;1&#125;, &#123;2&#125;'</span>.format(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)  <span class="comment"># a, b, c</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;1&#125;, &#123;0&#125;, &#123;2&#125;'</span>.format(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)  <span class="comment"># b, a, c</span></span><br></pre></td></tr></table></figure><h2 id="3-一些小Tips"><a href="#3-一些小Tips" class="headerlink" title="3.一些小Tips"></a>3.一些小Tips</h2><h4 id="1-共用内存的对象"><a href="#1-共用内存的对象" class="headerlink" title="1.共用内存的对象"></a>1.共用内存的对象</h4><p>每个对象被创建出来的时候，就会确定其Id标识，也就是给它分配内存地址。通常来说，新对象的内存地址也是新的，会从未分配的可用地址中取。</p><p>但是，为了提高内存利用效率，对于一些常用的对象，如一些数值较小的数字对象、布尔值对象、None对象、较短的字符串对象等等，python采取共用对象内存的分配策略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新分配内存地址的例子</span></span><br><span class="line">ww=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">ee=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">id(ww)==id(ee) &gt;&gt;&gt;<span class="literal">False</span></span><br><span class="line">a=<span class="number">2018</span></span><br><span class="line">b=<span class="number">2018</span></span><br><span class="line">id(a)==id(b) &gt;&gt;&gt;<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 共用内存地址的例子</span></span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">b=<span class="number">100</span></span><br><span class="line">id(a)==id(b) &gt;&gt;&gt;<span class="literal">True</span></span><br><span class="line">f1=<span class="literal">True</span></span><br><span class="line">f2=<span class="literal">True</span></span><br><span class="line">id(f1)==id(f2) &gt;&gt;&gt;<span class="literal">True</span></span><br><span class="line">n1=<span class="literal">None</span></span><br><span class="line">n2=<span class="literal">None</span></span><br><span class="line">id(n1)==id(n2) &gt;&gt;&gt;<span class="literal">True</span></span><br><span class="line">s=<span class="string">"python_cat"</span></span><br><span class="line">t=<span class="string">"python_cat"</span></span><br><span class="line">id(s)==id(t) &gt;&gt;&gt;<span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这就意味着，有一些变量，运行环境早早就为它们分配好了内存地址，一旦要创建新的对象时，先去已有的查找，有Type和Value相等的对象，则新对象不分配新的内存空间，而是指向已有对象。使得我们不需要频繁创建这些对象，既能提高已分配内存的使用率，又减少了创建对象、分配新内存的损耗。</p><blockquote><p>Python中，对于整数对象，如果其值处于[-5,256]的闭区间内（小整数池），则值相同的对象是同一个对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译对字符串拼接的影响</span></span><br><span class="line">s1 = <span class="string">"hell"</span></span><br><span class="line">s2 = <span class="string">"hello"</span></span><br><span class="line"><span class="string">"hell"</span> + <span class="string">"o"</span> <span class="keyword">is</span> s2 &gt;&gt;&gt;<span class="literal">True</span></span><br><span class="line">s1 + <span class="string">"o"</span> <span class="keyword">is</span> s2 &gt;&gt;&gt;<span class="literal">False</span></span><br><span class="line"><span class="comment"># "hell" + "o"在编译时变成了"hello"，</span></span><br><span class="line"><span class="comment"># 而s1+"o"因为s1是一个变量，在运行时才拼接，所以没有被intern</span></span><br></pre></td></tr></table></figure><blockquote><p>Python中，字符串使用Intern机制实现内存地址共用，长度不超过20，且仅包括下划线、数字、字母的字符串才会被intern；涉及字符串拼接时，编译期优化结果会与运行期计算结果不同。</p></blockquote><h4 id="2-isinstance-和-type-的区别："><a href="#2-isinstance-和-type-的区别：" class="headerlink" title="2.isinstance 和 type 的区别："></a>2.isinstance 和 type 的区别：</h4><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(A(), A)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(A()) == A </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(B(), A)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(B()) == A</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="3-大整数对象池"><a href="#3-大整数对象池" class="headerlink" title="3.大整数对象池"></a>3.大整数对象池</h4><p>在交互式终端环境中，每次创建大型数时都是去申请新的内存空间。但是在编写Python文件时每次运行都把代码加载到内存中，整个项目代码都属于一个整体。这时就是大型整数对象池发挥作用的时候了，它把处于相同代码块的所有等值的大型整数变量都处理为一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    b = <span class="number">100</span></span><br><span class="line">    c = <span class="number">1000</span></span><br><span class="line">    d = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    b = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(A.a <span class="keyword">is</span> A.b)  <span class="comment"># True</span></span><br><span class="line">print(A.a <span class="keyword">is</span> B.a)  <span class="comment"># True</span></span><br><span class="line">print(A.c <span class="keyword">is</span> A.d)  <span class="comment"># True</span></span><br><span class="line">print(A.b <span class="keyword">is</span> B.b)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h4 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4.内存管理"></a>4.内存管理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == id([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a), id(b))</span><br><span class="line"><span class="number">2037326252488</span> <span class="number">2037326229256</span></span><br></pre></td></tr></table></figure><p>Python会实时销毁没有引用计数的对象。一旦在内存中创建了一个对象但是没有为其添加引用计数，该段代码执行完后就会回收地址，在这个例子中计算完[1,2,3]的id后list被销毁，计算右边的id时list实时创建，复用了左边list用过的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一周学习——Python环境搭建及基本数据类型&quot;&gt;&lt;a href=&quot;#第一周学习——Python环境搭建及基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;第一周学习——Python环境搭建及基本数据类型&quot;&gt;&lt;/a&gt;第一周学习——Python环
      
    
    </summary>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/08/30/hello-world/"/>
    <id>http://yoursite.com/2019/08/30/hello-world/</id>
    <published>2019-08-30T09:27:48.660Z</published>
    <updated>2019-08-30T09:27:48.660Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
